一、Java的内存模型
	Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。（这里的变量包括
实例变量、静态字段和构成数组对象的元素，不包括局部变量与方法参数，因为后者是线程私有的，不存在竞争问题）
	Java的内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，
线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递
均需要通过主内存来完成。
	主内存与工作内存之间的交互协议定义了8种变量操作：lock、unlock、read、load、use、assign、store和write。
	
二、volatile型变量
	volatile是Java提供的最轻量级的同步机制，Java内存模型对volatile型变量定义了一些特殊的规则，一个volatile型变量具备两种特性：
	 a.可见性：对volatile变量的所有写操作都能立刻反应到其他线程中，即volatile变量在各线程中是一致的。
	 b.禁止指令重排序优化：这里的重排序值机器级的优化，两条线程对同一变量的8个子操作必须满足一定的先后规则。
	volatile变量不能保证操作的原子性，在不满足下面两个条件的情况下，仍然需要加锁来保证操作的原子性：
	 a.运算的结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
	 b.变量不需要与其他的状态变量共同参与不变约束。
	例如，有两个线程同时对volatile变量做++操作，如果两线程几乎同时从主内存中加载变量的值，这个值肯定是一样（volatile的立即同步特性），然后
各自在自己的工作内存中对变量执行自增1的操作，最后立即同步回主内存，由于同步的总有先后，及时是同时的，变量的值肯定只比原来大1，而不会大2，这
就是因为++操作被JVM解析后并不是单步的原子操作。

三、volatile和Synchronized的个人对比总结
1，效率一般比Synchronized高，volatile只能修饰变量，Synchronized可以修饰方法。
2，多线程访问，volatile不会发生阻塞，因为变量是实时同步回主内存的。
3，volatile可以保证数据的可见性（JVM保证从主内存加载到线程工作内存的值是最新的），但是不能保证数据的原子性。线程安全包含可见性、原子性和有序性
三个方面，Java的同步机制都是围绕这三个方面来确保线程安全的。
4，volatile解决的是变量在多个线程之间的可见性，而Synchronized侧重的是多个线程之间访问资源的同步性。

四、其他
在-server模式下，为了提高线程的执行效率，各线程在运行期会直接使用各自工作内存中的变量，而不会去主内存查找。这种模式在多线程中处理共享数据时，
会发生数据不一致问题。